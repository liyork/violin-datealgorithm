1. 直接插入排序
基本思想：不断将记录插入到已排序号的有序表中。
时间复杂度：O(n^2)
空间复杂度:O(1)
稳定

2. 希尔排序
基本思想：不断缩小步长，间隔插入，最后一次是步长为1的直接插入。
时间复杂度:O(nlogn)
空间复杂度:O(1)
不稳定，因为俺增量分组进行排序。如5,1,1,5，如果采用步长为2，则第一个5和第三个1交换，这样两个1相对位置进行了交换。

3. 直接选择排序
基本思想：n次遍历，两两比较，一次遍历选择出最大值。
时间复杂度：O(n^2)
空间复杂度：O(1)
不稳定，比如2 2 2 1，第一次选出最小数1和第一个2交换，那么2的相对位置发生了改变。

4. 堆排序nlogn
基本思想：先建立堆，然后取出顶，与最后元素交换，调整剩余元素为新堆，依次进行n次，每次调整堆消耗logn，一共n次
时间复杂度:O(nlogn)
空间复杂度:O(1)
一般来说堆排序没有快速排序速度快，部分原因是堆排序在下滤操作中的循环比较复杂，而快速排序采用分治法的循环操作比较简单，
但堆排序对初始数据分布不敏感，在数组基本有序的情况下，快速排序的时间复杂度会降到O(N^2)，而堆排序对于任意排列的数据，其时间复杂度都是O(NlogN)
不稳定，比如5 5 5，这样，构建好最大堆后，第1个5和最后一个5要进行交换

5. 冒泡排序
基本思想：将序列中所有元素两两比较，每次得到最大值放在最后。
时间复杂度:O(n^2)
空间复杂度:O(1)
稳定

6. 快排
基本思想：每次分割两组数据，左边小于关键字，右边大于关键字，继续分割。
时间复杂度:最好-每次关键字平分O(nlogn)。最坏-数据全部有序，数组根节点的分解次数构成一颗二叉退化树，O(n^2)
空间复杂度:由于需要堆栈空间临时保存递归调用参数，堆栈空间的使用个数和递归调用的次数有关，由于二叉树可能是单支二叉树，深度为n-1，所以最坏-O(n)
不稳定

7. 归并
基本思想：每次将数组二分然后左右继续二分直到不能再分，然后合并
时间复杂度:O(nlogn)
空间复杂度:O(1)
稳定

8. 基数排序(桶排序)
基本思想：
时间复杂度:O(mn),m是数字的最大位数，由于要m次使用n个节点临时存放n个数据元素，因此，基数排序算法的空间复杂度为O(n)
稳定

排序算法优劣的标准：
1、时间复杂度。
2、空间复杂度：算法中使用的辅助存储空间是多少。当排序算法中使用的辅助存储空间与要排序数据元素的个数n无关时，其空间复杂度为O(1）。
3、稳定性。


各种排序算法性能比较：
排序方法     最好时间   平均时间  最坏时间    最坏辅助空间   稳定性
直接插入排序  O(n)     O(n^2)   O(n^2)    O(1)         稳定
希尔排序     O(nlogn)  O(nlogn)   O(nlogn)   O(1)         不稳定
直接选择排序  O(n^2)   O(n^2)   O(n^2)    O(1)          不稳定
堆排序       O(nlogn)  O(nlogn)  O(nlogn)   O(1)          不稳定
冒泡排序     O(n)      O(n^2)  O(n^2)     O(1)         稳定
快速排序     O(nlogn)  O(nlogn)   O(n^2)    O(n)         不稳定    
归并排序     O(nlogn)  O(nlogn)   O(nlogn)   O(n)         稳定
基数排序     O(mn)    O(mn)     O(mn)     O(n)         稳定    



//时间固定nlogn，但是费内存

//堆排序的作用，优先级队列，top K问题